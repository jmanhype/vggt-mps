name: Recursive Self-Improve (RLM)

on:
  schedule:
    # Twice daily: 06:00 and 18:00 America/Chicago (11:00 and 23:00 UTC)
    - cron: "0 11 * * *"
    - cron: "0 23 * * *"
  workflow_dispatch:
    inputs:
      max_depth:
        description: 'Maximum recursive depth'
        required: false
        default: '3'
      focus_area:
        description: 'Focus area (tests, docs, perf, security, or auto)'
        required: false
        default: 'auto'

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  recursive-improve:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        depth: [1, 2, 3]
      max-parallel: 1  # Sequential execution for dependency tracking

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for conflict detection

      - name: Setup execution trace
        run: |
          mkdir -p .rlm-trace
          echo "RLM_DEPTH=${{ matrix.depth }}" >> $GITHUB_ENV
          echo "RLM_RUN_ID=${{ github.run_id }}" >> $GITHUB_ENV
          echo "RLM_START_TIME=$(date -u +%s)" >> $GITHUB_ENV

      - name: "RLM Depth ${{ matrix.depth }} - Analysis & Implementation"
        id: rlm-step
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are a RECURSIVE LANGUAGE MODEL (RLM) conducting self-improvement.

            === RLM METADATA ===
            Current Depth: ${{ matrix.depth }}
            Max Depth: ${{ github.event.inputs.max_depth || 3 }}
            Focus Area: ${{ github.event.inputs.focus_area || 'auto' }}
            Run ID: ${{ github.run_id }}
            Parent Commit: ${{ github.sha }}

            === RECURSIVE EXECUTION STRATEGY (inspired by Zhang & Khattab 2025) ===

            You operate as an RLM with REPL-style interaction over the codebase:

            DEPTH 1 (ROOT LM) - PEEK & PARTITION:
            - Use Glob to understand repository structure (PEEK)
            - Read key files (README, main code, tests) selectively
            - Use Grep to find TODOs, FIXMEs, error patterns
            - PARTITION work into 2-4 focused improvement areas
            - Create execution trace: .rlm-trace/depth-1-plan.md

            DEPTH 2 (RECURSIVE LM) - MAP & IMPLEMENT:
            - Read execution trace from depth 1: .rlm-trace/depth-1-plan.md
            - GREP for specific patterns identified by depth 1
            - Implement fixes for ONE partition from depth 1
            - Create execution trace: .rlm-trace/depth-2-changes-<area>.md
            - Check for conflicts with other depth-2 changes

            DEPTH 3 (AGGREGATION LM) - INTEGRATE & RESOLVE:
            - Read all execution traces from depth 1 and 2
            - DETECT conflicts between parallel changes
            - RESOLVE conflicts using 3-way merge strategy
            - VALIDATE all changes work together
            - Create final trace: .rlm-trace/depth-3-integration.md

            === EXECUTION TRACE FORMAT ===

            Each depth MUST create a trace file with:

            ```markdown
            # RLM Execution Trace - Depth ${{ matrix.depth }}

            ## Input Context
            - Parent Commit: <commit-hash>
            - Focus Area: <area>
            - Files Analyzed: [list]

            ## Discoveries (PEEK/GREP results)
            - Pattern 1: <what was found>
            - Pattern 2: <what was found>

            ## Actions Taken (MAP/IMPLEMENT)
            - Action 1: <what was changed>
            - Action 2: <what was changed>

            ## Conflicts Detected
            - Conflict 1: <description>
            - Resolution: <how it was resolved>

            ## Validation
            - Tests run: <commands>
            - Tests passed: <yes/no>

            ## Receipt
            Hash: <sha256 of changes>
            ```

            === CONFLICT RESOLUTION PROTOCOL ===

            When conflicts are detected:

            1. **Detection**: Check for overlapping file changes across depths
               ```bash
               # Compare changed files between traces
               comm -12 <(sort depth-1-files.txt) <(sort depth-2-files.txt)
               ```

            2. **Analysis**: Determine conflict type
               - OVERLAPPING: Same lines modified differently
               - DEPENDENT: Changes depend on each other's order
               - SEMANTIC: Changes conflict in meaning, not text

            3. **Resolution Strategy**:
               - OVERLAPPING ‚Üí 3-way merge with base commit
               - DEPENDENT ‚Üí Reorder changes, rebase if needed
               - SEMANTIC ‚Üí Use newer depth's understanding (depth 3 > 2 > 1)

            4. **Validation**: After resolution, run tests
               ```bash
               pytest tests/ || make test || python -m pytest
               ```

            === EXECUTION FEEDBACK LOOP ===

            Use execution traces to inform deeper recursion:

            ```python
            # Pseudo-code for how traces guide recursion
            if depth == 1:
                analysis = peek_grep_partition(codebase)
                write_trace(analysis)
                decide_partitions()  # Creates work for depth 2

            elif depth == 2:
                parent_analysis = read_trace(depth=1)
                my_partition = get_assigned_partition()
                changes = implement_partition(my_partition)
                conflicts = detect_conflicts_with_siblings()
                write_trace(changes, conflicts)

            elif depth == 3:
                all_changes = read_all_traces(depth=2)
                conflicts = analyze_conflicts(all_changes)
                resolved = resolve_conflicts(conflicts)
                integrated = validate_integration(resolved)
                write_trace(integrated)
                create_pr()
            ```

            === CURRENT TASK (Depth ${{ matrix.depth }}) ===

            ${{ matrix.depth == 1 && 'PEEK, GREP, PARTITION the codebase. Identify 2-4 improvement areas. Create execution trace.' || '' }}
            ${{ matrix.depth == 2 && 'Read depth-1 trace. Implement ONE partition. Detect conflicts. Create execution trace.' || '' }}
            ${{ matrix.depth == 3 && 'Read all traces. Resolve conflicts. Integrate changes. Validate. Create PR with receipt.' || '' }}

            === CONSTRAINTS ===

            - Max turns: ${{ matrix.depth == 1 && '40' || matrix.depth == 2 && '50' || '40' }}
            - Must create execution trace at .rlm-trace/depth-${{ matrix.depth }}-*.md
            - Must check for conflicts before committing
            - Must validate changes with tests (if available)
            - Must include receipt hash in final trace

            === TOOLS PREFERENCE ===

            - PEEK: Use Glob, Read (selective)
            - GREP: Use Grep tool (not bash grep)
            - PARTITION: Use analysis, not file operations
            - MAP: Use Edit/Write for changes
            - VALIDATE: Use Bash for test execution

            Remember: You are a recursive language model. Your execution trace is the context
            for deeper recursion levels. Think like a REPL environment - each depth builds on
            the previous depth's output stored in execution traces.

          claude_args: |
            --max-turns ${{ matrix.depth == 1 && 40 || matrix.depth == 2 && 50 || 40 }}
            --model claude-sonnet-4-5-20250929
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(gh:*),Bash(pytest:*),Bash(python:*),Bash(make:*),Bash(test:*),Bash(npm:*)"
            --system-prompt "You are a Recursive Language Model (RLM) at depth ${{ matrix.depth }}. Use execution traces to coordinate with other depths. Implement RLM patterns: PEEK, GREP, PARTITION, MAP, AGGREGATE. Focus on conflict detection and resolution."

      - name: Save execution trace
        if: always()
        run: |
          mkdir -p .rlm-trace
          # Trace should have been created by Claude Code
          if ls .rlm-trace/depth-${{ matrix.depth }}-*.md 1> /dev/null 2>&1; then
            echo "‚úì Execution trace saved"
            cat .rlm-trace/depth-${{ matrix.depth }}-*.md
          else
            echo "‚ö†Ô∏è No execution trace found - creating fallback"
            echo "# RLM Execution Trace - Depth ${{ matrix.depth }} (Fallback)" > .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "" >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "## Status" >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "No trace was created by the RLM execution." >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "" >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "## Timestamp" >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
            echo "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .rlm-trace/depth-${{ matrix.depth }}-fallback.md
          fi

      - name: Upload execution traces
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rlm-traces-depth-${{ matrix.depth }}
          path: .rlm-trace/
          retention-days: 30

  aggregate-and-pr:
    needs: recursive-improve
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all execution traces
        uses: actions/download-artifact@v4
        with:
          pattern: rlm-traces-*
          path: .rlm-trace/
          merge-multiple: true

      - name: Analyze traces and create PR
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "=== RLM Execution Summary ==="

          # Check if any depth created a PR already
          EXISTING_PR=$(gh pr list --head $(git branch --show-current) --json number --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "‚úì PR already created by depth 3: #$EXISTING_PR"

            # Trigger Qodo review
            gh pr comment $EXISTING_PR --body "/describe"
            gh pr comment $EXISTING_PR --body "/review"

            echo "‚úì Qodo review triggered on PR #$EXISTING_PR"
          else
            echo "‚ö†Ô∏è No PR was created - checking execution traces..."

            # List all traces
            find .rlm-trace -name "*.md" -type f | while read trace; do
              echo "--- $(basename $trace) ---"
              cat "$trace"
              echo ""
            done
          fi

      - name: Comment execution traces on PR
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=$(gh pr list --head $(git branch --show-current) --json number --jq '.[0].number' || echo "")

          if [ -n "$PR_NUMBER" ]; then
            # Create summary comment with all traces
            {
              echo "## üîÑ Recursive Execution Traces"
              echo ""
              echo "This PR was created through recursive self-improvement with execution feedback."
              echo ""
              find .rlm-trace -name "*.md" -type f | sort | while read trace; do
                echo "<details>"
                echo "<summary>üìã $(basename $trace)</summary>"
                echo ""
                echo '```markdown'
                cat "$trace"
                echo '```'
                echo "</details>"
                echo ""
              done
            } > /tmp/trace-comment.md

            gh pr comment $PR_NUMBER --body-file /tmp/trace-comment.md
            echo "‚úì Posted execution traces to PR #$PR_NUMBER"
          fi

  # TRUE RECURSIVE LOOP: Read Qodo feedback and incorporate it
  qodo-feedback-loop:
    needs: aggregate-and-pr
    runs-on: ubuntu-latest
    if: always()
    strategy:
      matrix:
        iteration: [1, 2, 3]  # Max 3 iterations
      max-parallel: 1  # Sequential - wait for Qodo review each time

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Wait for Qodo review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=$(gh pr list --head $(git branch --show-current) --json number --jq '.[0].number' || echo "")

          if [ -z "$PR_NUMBER" ]; then
            echo "‚ö†Ô∏è No PR found, skipping feedback loop"
            exit 0
          fi

          echo "‚è≥ Waiting for Qodo review on PR #$PR_NUMBER (iteration ${{ matrix.iteration }})..."

          # Wait up to 5 minutes for Qodo to respond
          for i in {1..30}; do
            QODO_COMMENTS=$(gh api repos/${{ github.repository }}/issues/$PR_NUMBER/comments \
              | jq -r '[.[] | select(.user.login | contains("qodo"))] | length')

            if [ "$QODO_COMMENTS" -gt "0" ]; then
              echo "‚úì Qodo has posted $QODO_COMMENTS comments"
              break
            fi

            echo "  Waiting... ($i/30)"
            sleep 10
          done

      - name: Read Qodo feedback and incorporate changes
        id: feedback-iteration
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          show_full_output: true
          prompt: |
            You are in a RECURSIVE FEEDBACK LOOP (iteration ${{ matrix.iteration }}/3).

            === MISSION ===
            Read Qodo Merge Pro's review feedback on the PR and incorporate ALL suggested improvements.
            This is the TRUE recursive loop - you improve based on execution feedback!

            === EXECUTION FEEDBACK SOURCE ===

            Qodo Merge Pro has analyzed your PR and provided:
            1. PR Description (/describe output)
            2. Code Review (/review output)
            3. Suggested improvements
            4. Compliance issues
            5. Security concerns
            6. Performance recommendations

            === YOUR TASK ===

            STEP 1: FETCH QODO FEEDBACK
            ```bash
            # Get PR number
            PR_NUM=$(gh pr list --head $(git branch --show-current) --json number --jq '.[0].number')

            # Fetch all Qodo comments
            gh api repos/${{ github.repository }}/issues/$PR_NUM/comments \
              | jq -r '.[] | select(.user.login | contains("qodo")) | .body' \
              > .rlm-trace/qodo-feedback-iter-${{ matrix.iteration }}.md

            # Read the feedback
            cat .rlm-trace/qodo-feedback-iter-${{ matrix.iteration }}.md
            ```

            STEP 2: ANALYZE FEEDBACK
            Parse Qodo's review to identify:
            - üî¥ Critical issues (MUST fix)
            - üü° Suggested improvements (SHOULD fix)
            - üü¢ Nice-to-haves (MAY fix)
            - ‚úÖ Approved items (keep as-is)

            STEP 3: IMPLEMENT IMPROVEMENTS
            For each issue/suggestion from Qodo:
            - Read the file mentioned
            - Apply the suggested fix
            - Validate it doesn't break anything
            - Update execution trace

            STEP 4: VALIDATE
            ```bash
            # Run tests if available
            pytest tests/ || make test || python -m pytest || npm test
            ```

            STEP 5: COMMIT & PUSH
            ```bash
            git add .
            git commit -m "fix: incorporate Qodo feedback (iteration ${{ matrix.iteration }})

            Applied Qodo Merge Pro suggestions:
            - [list specific changes]

            Iteration: ${{ matrix.iteration }}/3
            Receipt: $(git rev-parse HEAD)"

            git push origin $(git branch --show-current)
            ```

            STEP 6: CREATE FEEDBACK TRACE
            Document what you changed in response to Qodo:

            ```markdown
            # Qodo Feedback Iteration ${{ matrix.iteration }}

            ## Feedback Received
            [Summary of Qodo's review]

            ## Critical Issues Fixed
            - Issue 1: [description]
              - File: [file]
              - Fix: [what you did]

            ## Improvements Implemented
            - Improvement 1: [description]
              - File: [file]
              - Change: [what you did]

            ## Skipped (with rationale)
            - Suggestion X: [why you didn't implement it]

            ## Validation
            - Tests run: [command]
            - Tests passed: [yes/no]

            ## Receipt
            Commit: $(git rev-parse HEAD)
            Iteration: ${{ matrix.iteration }}/3
            ```

            === STOPPING CONDITION ===

            If Qodo's latest review shows:
            - No critical issues
            - No "must fix" suggestions
            - Mostly approvals

            Then add this to your trace:
            ```
            ## Loop Termination
            Qodo feedback loop complete - no critical issues remaining.
            ```

            And exit successfully.

            === IMPORTANT ===

            - This is EXECUTION FEEDBACK - the recursive loop in RLMs
            - You're reading Qodo's analysis of your OWN code
            - Incorporate the feedback to improve the PR
            - Each iteration makes the PR better
            - Max 3 iterations to avoid infinite loops
            - Be surgical - only change what Qodo suggested

            Remember: This is the TRUE recursive pattern - read execution traces (Qodo's review),
            improve based on feedback, then Qodo reviews again. Repeat until convergence!

          claude_args: |
            --max-turns 50
            --model claude-sonnet-4-5-20250929
            --allowedTools "Read,Write,Edit,Glob,Grep,Bash(git:*),Bash(gh:*),Bash(pytest:*),Bash(python:*),Bash(make:*),Bash(test:*),Bash(npm:*)"
            --system-prompt "You are in a recursive feedback loop. Read Qodo's review, implement ALL suggestions, push changes. This is execution feedback - the core of recursive improvement!"

      - name: Re-trigger Qodo review
        if: steps.feedback-iteration.conclusion == 'success'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER=$(gh pr list --head $(git branch --show-current) --json number --jq '.[0].number' || echo "")

          if [ -n "$PR_NUMBER" ]; then
            echo "üîÑ Triggering Qodo review for iteration ${{ matrix.iteration }}"
            gh pr comment $PR_NUMBER --body "/review"

            # Comment about iteration
            gh pr comment $PR_NUMBER --body "üîÑ **Recursive Feedback Loop - Iteration ${{ matrix.iteration }}/3**

            Incorporated Qodo's feedback and updated the PR. Requesting re-review to validate improvements."
          fi

      - name: Upload feedback trace
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qodo-feedback-iter-${{ matrix.iteration }}
          path: .rlm-trace/qodo-feedback-iter-${{ matrix.iteration }}.md
          retention-days: 30
